# [\#14](https://shikumirb.connpass.com/event/368546/)

## やったこと

前回に続き、[kaneko\.y（\@spikeolaf）](https://x.com/spikeolaf) さんが作成された lr-parser-101 を使って、みんなでワイワイしながらパーサを生成しました！

[yui\-knk/lr\-parser\-101](https://github.com/yui-knk/lr-parser-101)

### 第 4 章

第 4 章では四則演算の計算式を受け取って、その計算結果を表示するシンプルなパーサを作る。

今回は掛け算を実装する。

#### 掛け算の実装

演算子の優先順位が正しくなるように文法ルールを書く必要がある。

天下り的だが、以下のような文法ルールを書いてみる。

```ruby
rule
  program: expr { p val[0] }
         ;

  expr: term { result = val[0] }
      | expr '+' term { result = val[0] + val[2] }
      ;

  term: NUMBER { result = val[0] }
      | term '*' NUMBER { result = val[0] * val[2] }
      ;
end
```

これは数学の**多項式**（expr に相当）と**単項式**（term に相当）の定義を BNF で表したものと解釈できそう。

`racc` を利用してパーサを生成する。Rakefile にパーサを生成するためのコマンドが記載されているので、ここではそのコマンドを直接実行してみる。

```sh
❯ cat Rakefile 
task default: :compile

task :compile do
  puts "Compiling parser ..."

  `racc calc.y -o calc.rb`
end

❯ ls | grep calc.rb

# Rakefile に記載されているコマンドを実行
❯ racc calc.y -o calc.rb

❯ ls | grep calc.rb     
calc.rb
```

生成されたパーサを実行してみる。

```sh
❯ ruby calc.rb
Enter the formula:
2 * 3 * 4
24

Enter the formula:
2 * 3 + 4
10

Enter the formula:
2 + 3 * 4
14

Enter the formula:
q
Bye!
```

確かに複数回の足し算、掛け算の結果が正しく表示される。

##### LALR(1) パーサに関する考察

先ほどの BNF だと、以下のような状況で Shift/Reduce コンフリクトが発生しそうな気もする。

```sh
Stack (Parser)     | Queue (Lexer)
----------------------------------------------------------
                   | NUMBER(1) '+' NUMBER(2) '*' NUMBER(3)
NUMBER(1)          | '+' NUMBER(2) '*' NUMBER(3)
term               | '+' NUMBER(2) '*' NUMBER(3)
expr               | '+' NUMBER(2) '*' NUMBER(3)
expr '+'           | NUMBER(2) '*' NUMBER(3)
expr '+' NUMBER(2) | '*' NUMBER(3)
expr '+' term      | '*' NUMBER(3) # Shift/Reduce のどちらを選択すべきか？
```

ここで仮に Reduce を選択したすると、次のトークンが `'*'` なので以下のようになって手詰まりになる。

```sh
Stack (Parser)     | Queue (Lexer)
----------------------------------------------------------
expr               | '*' NUMBER(3) # Reduce を選択すると手詰まり
```

LALR(1) パーサはトークンを 1 つ**先読み**することで Shift を正しく選択しているように見える。

##### `calc.output` ファイルを確認する

このことを確認するために、`calc.output` を生成する。

Rakefile にパーサを生成するためのコマンドが記載されているので、ここではそのコマンドに `-v` オプションを付けて実行してみる。

```sh
❯ cat Rakefile 
task default: :compile

task :compile do
  puts "Compiling parser ..."

  `racc calc.y -o calc.rb`
end

❯ ls | grep calc.output

# Rakefile に記載されているコマンドに -v オプションを付けて実行
❯ racc calc.y -o calc.rb -v

❯ ls | grep calc.output    
calc.output
```

生成された `calc.output` を確認してみると、以下のように記述されている。

```sh
❯ cat calc.output| grep -A 9 '^state 9'
state 9

   3) expr : expr "+" term _
   5) term : term _ "*" NUMBER

  "*"           shift, and go to state 7
  $default      reduce using rule 3 (expr)


state 10
```

これを見た感じ、以下の予想は当たっていそう。

> LALR(1) パーサはトークンを 1 つ**先読み**することで Shift を正しく選択しているように見える。
