# [\#8](https://shikumirb.connpass.com/event/361796/)

## やったこと

[kaneko\.y（\@spikeolaf）](https://x.com/spikeolaf) さんから教えていただいた方法で、みんなでワイワイしながら Ruby をビルドしました！

さらに、ビルドしたときに生成される `parse.output` を使って LALR パーサの動きをログから読み解くための下準備をしました！

### Ruby のビルド

Ruby のビルド時にオプションを指定すると `parse.output` を生成することができる。[^1]

[^1]: `parse.output` を生成するための Ruby のビルド方法については以下を参照。[meetups/reports/2025/0704\.md at main · shikumirb/meetups](https://github.com/shikumirb/meetups/blob/main/reports/2025/0704.md)

### parse.output を読んでみる

実際に Ruby をビルドした際に生成される `parse.output` を読んでみる。

ここでは、`state 0` のときの Parser のアクションと状態遷移が記述されている箇所を見てみる。

```
~/workspace/ruby_under_a_microscope/ruby/build master ⇣
❯ cat parse.output | grep '^State 0' -A 10
State 0

    0 $accept: • program "end-of-input"
    1 $@1: ε •
    5 program: • $@1 compstmt_top_stmts

    $default  reduce using rule 1 ($@1)

    $@1      go to state 1
    program  go to state 2
```

これを読むと、`state 0` のときは Parser は先読みせずに文法ルール 1 を利用して還元（Reduce）することがわかる。

さらに、還元した結果生じる `$@1` というトークンをスタックに積むと、`state 1` に遷移することがわかる。

### LALR パーサの動きをログ出力する

`ruby` コマンドに以下のようなオプションを指定して実行すると、LALR パーサの動きがログに出力される。

ここでは実際にビルドして生成される `miniruby` を利用している。

```
~/workspace/ruby_under_a_microscope/ruby/build master ⇣
❯ ./miniruby --parser=parse.y --dump=y -e '1'
add_delayed_token:7632 (0: 0|0|0)
Starting parse
Entering state 0
Stack now 0
Reducing stack by rule 1 (line 3158):
lex_state: NONE -> BEG at line 3159
vtable_alloc:14798: 0x0000600000b3a040
vtable_alloc:14799: 0x0000600000b3a060
cmdarg_stack(push): 0 at line 14813
cond_stack(push): 0 at line 14814
-> $$ = nterm $@1 (1.0-1.0: )
Entering state 1
Stack now 0 1
Reading a token
lex_state: BEG -> END at line 9663
lex_state: END -> END at line 8957
parser_dispatch_scan_event:11164 (1: 0|1|1)
Next token is token "integer literal" (1.0-1.1: 1)
Shifting token "integer literal" (1.0-1.1: 1)
Entering state 40
Stack now 0 1 40
Reducing stack by rule 684 (line 6163):
   $1 = token "integer literal" (1.0-1.1: 1)
-> $$ = nterm simple_numeric (1.0-1.1: NODE_INTEGER)
Entering state 135
Stack now 0 1 135
Reducing stack by rule 682 (line 6154):
   $1 = nterm simple_numeric (1.0-1.1: NODE_INTEGER)
-> $$ = nterm numeric (1.0-1.1: NODE_INTEGER)
Entering state 134
Stack now 0 1 134
Reducing stack by rule 630 (line 5882):
   $1 = nterm numeric (1.0-1.1: NODE_INTEGER)
-> $$ = nterm literal (1.0-1.1: NODE_INTEGER)
Entering state 117
Stack now 0 1 117
Reducing stack by rule 338 (line 4353):
   $1 = nterm literal (1.0-1.1: NODE_INTEGER)
-> $$ = nterm primary (1.0-1.1: NODE_INTEGER)
Entering state 99
Stack now 0 1 99
Reading a token
lex_state: END -> BEG at line 10569
parser_dispatch_scan_event:11164 (1: 1|1|0)
Next token is token '\n' (1.1-1.2: )
Reducing stack by rule 283 (line 4048):
   $1 = nterm primary (1.0-1.1: NODE_INTEGER)
-> $$ = nterm arg (1.0-1.1: NODE_INTEGER)
Entering state 93
Stack now 0 1 93
Next token is token '\n' (1.1-1.2: )
Reducing stack by rule 78 (line 3490):
   $1 = nterm arg (1.0-1.1: NODE_INTEGER)
-> $$ = nterm expr (1.0-1.1: NODE_INTEGER)
Entering state 79
Stack now 0 1 79
Next token is token '\n' (1.1-1.2: )
Reducing stack by rule 45 (line 3405):
   $1 = nterm expr (1.0-1.1: NODE_INTEGER)
-> $$ = nterm stmt (1.0-1.1: NODE_INTEGER)
Entering state 73
Stack now 0 1 73
Next token is token '\n' (1.1-1.2: )
Reducing stack by rule 9 (line 3201):
   $1 = nterm stmt (1.0-1.1: NODE_INTEGER)
-> $$ = nterm top_stmt (1.0-1.1: NODE_INTEGER)
Entering state 71
Stack now 0 1 71
Reducing stack by rule 7 (line 3189):
   $1 = nterm top_stmt (1.0-1.1: NODE_INTEGER)
-> $$ = nterm top_stmts (1.0-1.1: NODE_INTEGER)
Entering state 70
Stack now 0 1 70
Next token is token '\n' (1.1-1.2: )
Shifting token '\n' (1.1-1.2: )
Entering state 330
Stack now 0 1 70 330
Reducing stack by rule 808 (line 6710):
   $1 = token '\n' (1.1-1.2: )
-> $$ = nterm term (1.1-1.1: )
Entering state 333
Stack now 0 1 70 333
Reducing stack by rule 809 (line 6717):
   $1 = nterm term (1.1-1.1: )
-> $$ = nterm terms (1.1-1.1: )
Entering state 334
Stack now 0 1 70 334
Reading a token
Now at end of input.
Reducing stack by rule 3 (line 3164):
   $1 = nterm terms (1.1-1.1: )
-> $$ = nterm option_terms (1.1-1.1: )
Entering state 332
Stack now 0 1 70 332
Reducing stack by rule 4 (line 3164):
   $1 = nterm top_stmts (1.0-1.1: NODE_INTEGER)
   $2 = nterm option_terms (1.1-1.1: )
-> $$ = nterm compstmt_top_stmts (1.0-1.1: NODE_INTEGER)
Entering state 69
Stack now 0 1 69
Reducing stack by rule 5 (line 3164):
   $1 = nterm $@1 (1.0-1.0: )
   $2 = nterm compstmt_top_stmts (1.0-1.1: NODE_INTEGER)
vtable_free:14824: cur_table(0x0000600000b3a040)
vtable_free:14824: cur_table(0x0000600000b3a060)
cmdarg_stack(pop): 0 at line 14854
cond_stack(pop): 0 at line 14855
-> $$ = nterm program (1.0-1.1: )
Entering state 2
Stack now 0 2
Now at end of input.
Shifting token "end-of-input" (1.2-1.2: )
Entering state 143
Stack now 0 2 143
Stack now 0 2 143
Cleanup: popping token "end-of-input" (1.2-1.2: )
Cleanup: popping nterm program (1.0-1.1: )
```
