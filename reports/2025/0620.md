# [\#6](https://shikumirb.connpass.com/event/359298/)

## やったこと

「Ruby のしくみ」をみんなでワイワイ言いながら読み進めました！

[Rubyのしくみ　Ruby Under a Microscope【委託】 \- 達人出版会](https://tatsu-zine.com/books/ruby-under-a-microscope-ja)

### Ripper を利用した構文解析

- `Ripper.sexp` に Ruby のスクリプトを文字列として渡すと、構文解析した結果を返してくれる。[^1]

[^1]: Ruby のバージョンについては以下を参照。[meetups/reports/2025/0530\.md at main · shikumirb/meetups](https://github.com/shikumirb/meetups/blob/main/reports/2025/0530.md#ruby-%E3%81%AE%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3)

```sh
❯ irb
irb(main):001:0> require 'ripper'
=> true
irb(main):002:0> require 'pp'
=> true
irb(main):003:0> pp Ripper.sexp('123 + 456')
[:program, [[:binary, [:@int, "123", [1, 0]], :+, [:@int, "456", [1, 6]]]]]
```

- 等価に見える Ruby スクリプトでも、書き方が異なればパーサの出力も異なることに注意する。例えば、以下の 4 つの式をパースした結果はそれぞれ異なる。

```ruby
puts 1
puts(1)
Kernel.puts 1
Kernel.puts(1)
```

実際に確認してみると、それぞれ以下のようになる。

```sh
irb(main):004:0> pp Ripper.sexp('puts 1')
[:program,
 [[:command,
   [:@ident, "puts", [1, 0]],
   [:args_add_block, [[:@int, "1", [1, 5]]], false]]]]
```

```sh
irb(main):005:0> pp Ripper.sexp('puts(1)')
[:program,
 [[:method_add_arg,
   [:fcall, [:@ident, "puts", [1, 0]]],
   [:arg_paren, [:args_add_block, [[:@int, "1", [1, 5]]], false]]]]]
```

```sh
irb(main):006:0> pp Ripper.sexp('Kernel.puts 1')
[:program,
 [[:command_call,
   [:var_ref, [:@const, "Kernel", [1, 0]]],
   :".",
   [:@ident, "puts", [1, 7]],
   [:args_add_block, [[:@int, "1", [1, 12]]], false]]]]
```

```sh
irb(main):007:0> pp Ripper.sexp('Kernel.puts(1)')
[:program,
 [[:method_add_arg,
   [:call,
    [:var_ref, [:@const, "Kernel", [1, 0]]],
    :".",
    [:@ident, "puts", [1, 7]]],
   [:arg_paren, [:args_add_block, [[:@int, "1", [1, 12]]], false]]]]]
```
