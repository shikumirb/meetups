# [\#20](https://shikumirb.connpass.com/event/378305/)

## やったこと

今日は `ruby` コマンドの `--dump` オプションを利用して LR パーサのデバッグ情報を出力してワイワイしました！

### `--dump` オプション

以下では Ruby のバージョン 3.4.5 を利用している。

```sh
❯ ruby -v
ruby 3.4.5 (2025-07-16 revision 20cda200d3) +PRISM [x86_64-darwin22]
```

`--dump` オプションを使うと、パーサジェネレータが生成するデバッグ情報やパーサが生成する AST を出力することができる。

```sh
❯ ruby --help | grep -A 6 "Dump List"
Dump List:
（略）
  yydebug         yydebug of yacc parser generator.
  parsetree       Abstract syntax tree (AST).
（略）
```

### AST の出力

AST は以下のようにして出力できる。（ここでは引数で空スクリプトを指定）

```sh
❯ ruby --parser=parse.y --dump=parsetree -e ""   
（中略）
# @ NODE_SCOPE (id: 1, line: 1, location: (1,0)-(1,0))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_BEGIN (id: 0, line: 1, location: (1,0)-(1,0))
#     +- nd_body:
#         (null node)
```

木構造を図示するとこんな感じ？

```
@ NODE_SCOPE
      |
@ NODE_BEGIN
```

リテラルの `1` のみのスクリプトを引数で指定して AST を出力してみる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "1"
（中略）
# @ NODE_SCOPE (id: 1, line: 1, location: (1,0)-(1,1))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_INTEGER (id: 0, line: 1, location: (1,0)-(1,1))*
#     +- val: 1
```

木構造を図示するとこんな感じ？

```
@ NODE_SCOPE
      |
@ NODE_INTEGER
```

`nil` のみのスクリプトを引数で指定して AST を出力してみる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "nil"
（中略）
# @ NODE_SCOPE (id: 1, line: 1, location: (1,0)-(1,3))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_NIL (id: 0, line: 1, location: (1,0)-(1,3))*
```

木構造を図示するとこんな感じ？

```
@ NODE_SCOPE
      |
@ NODE_NIL
```

`true` のみのスクリプトを引数で指定して AST を出力してみる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "true"
（中略）
# @ NODE_SCOPE (id: 1, line: 1, location: (1,0)-(1,4))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_TRUE (id: 0, line: 1, location: (1,0)-(1,4))*
```

木構造を図示するとこんな感じ？

```
@ NODE_SCOPE
      |
@ NODE_TRUE
```

`self` のみのスクリプトを引数で指定して AST を出力してみる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "self"
（中略）
# @ NODE_SCOPE (id: 1, line: 1, location: (1,0)-(1,4))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_SELF (id: 0, line: 1, location: (1,0)-(1,4))*
#     +- nd_state: 1
```

木構造を図示するとこんな感じ？

```
@ NODE_SCOPE
      |
@ NODE_SELF
```

`puts 1` というスクリプトを引数で指定して AST を出力してみる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "puts 1"
（中略）
# @ NODE_SCOPE (id: 3, line: 1, location: (1,0)-(1,6))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_FCALL (id: 1, line: 1, location: (1,0)-(1,6))*
#     +- nd_mid: :puts
#     +- nd_args:
#         @ NODE_LIST (id: 2, line: 1, location: (1,5)-(1,6))
#         +- as.nd_alen: 1
#         +- nd_head:
#         |   @ NODE_INTEGER (id: 0, line: 1, location: (1,5)-(1,6))
#         |   +- val: 1
#         +- nd_next:
#             (null node)
```

木構造を図示するとこんな感じ？

```
@ NODE_SCOPE
      |
@ NODE_FCALL
      |
@ NODE_LIST
      |
@ NODE_INTEGER
```

`puts 1, 2` というスクリプトを引数で指定して AST を出力してみる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "puts 1, 2"
（中略）
# @ NODE_SCOPE (id: 5, line: 1, location: (1,0)-(1,9))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_FCALL (id: 1, line: 1, location: (1,0)-(1,9))*
#     +- nd_mid: :puts
#     +- nd_args:
#         @ NODE_LIST (id: 2, line: 1, location: (1,5)-(1,9))
#         +- as.nd_alen: 2
#         +- nd_head:
#         |   @ NODE_INTEGER (id: 0, line: 1, location: (1,5)-(1,6))
#         |   +- val: 1
#         +- nd_head:
#         |   @ NODE_INTEGER (id: 3, line: 1, location: (1,8)-(1,9))
#         |   +- val: 2
#         +- nd_next:
#             (null node)
```

木構造を図示するとこんな感じ？

```
         @ NODE_SCOPE
               |
         @ NODE_FCALL
               |
         @ NODE_LIST
              / \
@ NODE_INTEGER   @ NODE_INTEGER
```

`1 + 2 * 3` というスクリプトを引数で指定して AST を出力してみる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "1 + 2 * 3"
（中略）
# @ NODE_SCOPE (id: 7, line: 1, location: (1,0)-(1,9))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_OPCALL (id: 6, line: 1, location: (1,0)-(1,9))*
#     +- nd_mid: :+
#     +- nd_recv:
#     |   @ NODE_INTEGER (id: 0, line: 1, location: (1,0)-(1,1))
#     |   +- val: 1
#     +- nd_args:
#         @ NODE_LIST (id: 5, line: 1, location: (1,4)-(1,9))
#         +- as.nd_alen: 1
#         +- nd_head:
#         |   @ NODE_OPCALL (id: 4, line: 1, location: (1,4)-(1,9))
#         |   +- nd_mid: :*
#         |   +- nd_recv:
#         |   |   @ NODE_INTEGER (id: 1, line: 1, location: (1,4)-(1,5))
#         |   |   +- val: 2
#         |   +- nd_args:
#         |       @ NODE_LIST (id: 3, line: 1, location: (1,8)-(1,9))
#         |       +- as.nd_alen: 1
#         |       +- nd_head:
#         |       |   @ NODE_INTEGER (id: 2, line: 1, location: (1,8)-(1,9))
#         |       |   +- val: 3
#         |       +- nd_next:
#         |           (null node)
#         +- nd_next:
#             (null node)
```

木構造を図示するとこんな感じ？

```
         @ NODE_SCOPE
               |
         @ NODE_OPCALL
              / \
@ NODE_INTEGER   @ NODE_LIST
                       |
                 @ NODE_OPCALL
                      / \
        @ NODE_INTEGER   @ NODE_LIST
                               |
                         @ NODE_INTEGER
```

### トークン列の出力

トークン列は以下のように少し工夫すれば出力できる。

```sh
❯ ruby --parser=parse.y --dump=yydebug -e "1 + 2 * 3" | grep 'Next token is token' | uniq
Next token is token "integer literal" (1.0-1.1: 1)
Next token is token '+' (1.2-1.3: )
Next token is token "integer literal" (1.4-1.5: 2)
Next token is token '*' (1.6-1.7: )
Next token is token "integer literal" (1.8-1.9: 3)
Next token is token '\n' (1.9-1.10: )
```

### マイナスについて

マイナス（`-`）はスペースの有無によって異なるトークンに変換される。

- `-1 ** 2` の場合は `tUMINUS_NUM` というトークンに変換される。

```sh
❯ ruby --parser=parse.y --dump=yydebug -e "-1 ** 2" | grep 'Next token is token' | uniq  
Next token is token tUMINUS_NUM (1.0-1.1: )
Next token is token "integer literal" (1.1-1.2: 1)
Next token is token "**" (1.3-1.5: )
Next token is token "integer literal" (1.6-1.7: 2)
Next token is token '\n' (1.7-1.8: )
```

- `- 1 ** 2` の場合は `unary-` というトークンに変換される。

```sh
❯ ruby --parser=parse.y --dump=yydebug -e "- 1 ** 2" | grep 'Next token is token' | uniq
Next token is token "unary-" (1.0-1.1: )
Next token is token "integer literal" (1.2-1.3: 1)
Next token is token "**" (1.4-1.6: )
Next token is token "integer literal" (1.7-1.8: 2)
Next token is token '\n' (1.8-1.9: )
```

「`-1 ** 2` と `- 1 ** 2` で演算子の優先順位が異なり、これを区別するためにトークンの種別が異なるのではないか」と予想。

しかし、irb  でこの 2 つを実際に実行してみるとどちらも `-1` が返ってくる。

```sh
❯ irb
irb(main):001> -1 ** 2
=> -1
irb(main):002> - 1 ** 2
=> -1
```

恐らく優先順位が異なるケースが何かあるはず。。。

### 追記

> 恐らく優先順位が異なるケースが何かあるはず。。。

[@shirakabesoft](https://x.com/shirakabesoft) さんが見つけてくださいました！圧倒的感謝。。。

https://x.com/shirakabesoft/status/2001995438606705120
<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsiZGF0YSI6MjcyOTE3LCJwdXIiOiJibG9iX2lkIn19--fc6461baf9c1035ba4f620538f345cc5bc0fbf17/image.png" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsiZGF0YSI6MjcyOTE3LCJwdXIiOiJibG9iX2lkIn19--fc6461baf9c1035ba4f620538f345cc5bc0fbf17/image.png" width="1184" height="1032" alt="image.png"></a>
