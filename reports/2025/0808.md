# [\#11](https://shikumirb.connpass.com/event/363910/)

## やったこと

前回に続き、[kaneko\.y（\@spikeolaf）](https://x.com/spikeolaf) さんが作成された lr-parser-101 を使って、みんなでワイワイしながらパーサを生成しました！

[yui\-knk/lr\-parser\-101](https://github.com/yui-knk/lr-parser-101)

### 第 2 章

第 2 章では足し算と引き算の計算式を受け取って、その計算結果を表示するシンプルなパーサを作る。

例題で足し算を実装して、演習で引き算を実装する。

#### 足し算の実装

まずは足し算を実装する。

そのために、`sample.y` をコピーして `calc.y` を作り、この中に BNF で文法ルールを書いていく。

今回は以下のような文法ルールを記述しただけ。

```diff
  rule
-   program: NUMBER { p "Input is #{val[0]}" }
+   program: NUMBER '+' NUMBER { p val[0] + val[2] }
+          | NUMBER { p val[0] }
           ;
```

Rakefile を確認すると、`racc` コマンドを実行しているだけ。

```ruby
task default: :compile

task :compile do
  puts "Compiling parser ..."

  `racc calc.y -o calc.rb`
end
```

この `racc` コマンドを実行すると `calc.rb` が生成される。

生成された `calc.rb` を実行して動作確認してみる。

```sh
❯ racc calc.y -o calc.rb

❯ ruby calc.rb
Enter the formula:
1 + 2
3

Enter the formula:
4 + 5
9

Enter the formula:
10
10

Enter the formula:
q
Bye!
```

足し算の結果を正しく出力しているように見える。

第 2 章の例題はクリア！🎉

#### トークン名の定義

`parse` メソッド内の `NUMBER` や `+` というトークン名を以下のように変更してみる。

```ruby
  def parse(str)
    @q = []
    ss = StringScanner.new(str)

    while !ss.eos? do
      case
      when ss.scan(/\s+/)
        # skip spaces
      when ss.scan(/(\d+)/)
        # @q << [:NUMBER, ss[0].to_i]
        @q << [:tNUMBER, ss[0].to_i]
      when ss.scan(/\+/)
        # @q << ['+', '+']
        @q << ['t+', 'v+']
```

BNF で使われるトークン名も同様に変更する。

```ruby
rule
  program: tNUMBER 't+' tNUMBER { p val[0] + val[2] }
         | tNUMBER { p val[0] }
         ;
```

上のように変更してから `calc.rb` を再生成しても動作は変わらない。

つまり、トークン名は `parse` メソッド内で定義され、このように定義されたトークン名を利用して文法ルールを記述していることになる。

#### トークン名と BNF で利用される記号の衝突

トークン名を定義するときは文字列かシンボルを利用する。ただし、トークン名としてシンボルを利用する場合は、BNF で利用される記号と衝突しないように注意する。

例えば、以下のように `:+` というシンボルをトークン名に利用してみる。

```diff
  rule
-   program: NUMBER '+' NUMBER { p val[0] + val[2] }
+   program: NUMBER + NUMBER { p val[0] + val[2] }
           | NUMBER { p val[0] }
           ;

-         @q << ['+', '+']
+         @q << [:+, '+']
```

この状態で `racc` コマンドを実行すると、`shift/reduce` コンフリクトが発生する。

```sh
❯ racc calc.y -o calc.rb
1 useless rules:
  #1 ("-many1@NUMBER")
2 shift/reduce conflicts
Turn on logging with "-v" and check ".output" file for details
```

詳細なログを調べるために、`racc` コマンドのオプションとして `-v` を指定してみる。

```sh
❯ racc calc.y -o calc.rb -v 
1 useless rules:
  #1 ("-many1@NUMBER")
2 shift/reduce conflicts
Check ".output" file for details
```

`calc.output` を見てみると、`state 2` と `state 5` で `shift/reduce` コンフリクトが起きているように見える。

```sh
state 2 contains 1 shift/reduce conflicts
state 5 contains 1 shift/reduce conflicts
```

`state 2` と `state 5` の箇所を見てみると、確かにコンフリクトしていそう。

```sh
state 2

   1) "-many1@NUMBER" : NUMBER _
   2) "-many1@NUMBER" : NUMBER _ "-many1@NUMBER"
   4) program : NUMBER _

  NUMBER        shift, and go to state 5
  NUMBER        [reduce using rule 1 ("-many1@NUMBER")]
  $default      reduce using rule 4 (program)

  "-many1@NUMBER"  go to state 6
```

```sh
state 5

   1) "-many1@NUMBER" : NUMBER _
   2) "-many1@NUMBER" : NUMBER _ "-many1@NUMBER"

  NUMBER        shift, and go to state 5
  NUMBER        [reduce using rule 1 ("-many1@NUMBER")]

  "-many1@NUMBER"  go to state 6
```

#### BNF で利用される記号

`+` はバッカス・ナウア記法の派生として、**直前のトークンの 1 回以上の繰り返し**を表す。

> BNF には様々な派生と拡張が存在し、一般に単純さと簡潔さのために拡張/修正されるか、特定の用途向けに適用させるべく拡張/修正されている。特によく行われる拡張は * や + といった正規表現の繰り返しオペレータの導入である。
>
> （中略）
> 
> 1回以上繰り返すアイテムには `+` を後置する。`<word> ::= <letter>+`
>
> [バッカス・ナウア記法 \- Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95#%E6%B4%BE%E7%94%9F)


`racc` はどうもこの `+` 記号をサポートしていそう。

その結果、`+` はトークン名としてではなく、BNF の記号として解釈されてしまっていた模様。

#### 実験

この仮説が正しいかどうかを実験で確認する。

`calc.y` を以下のように修正すると、スペース区切りの数字を入力として受け取れるようになるはず。

```diff
  rule
-   program: NUMBER { p "Input is #{val[0]}" }
+   program: NUMBER+ { p val }
           ;
```

実際に確認してみると、確かにスペース区切りの数字を入力として受け取れるようになった。

```ruby
❯ ruby calc.rb
Enter the formula:
1 2 3
[[1, 2, 3]]

Enter the formula:
4 5 6
[[4, 5, 6]]

Enter the formula:
q
Bye!
```
