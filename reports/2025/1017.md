# [\#16](https://shikumirb.connpass.com/event/371762/)

## やったこと

前回に続き、[kaneko\.y（\@spikeolaf）](https://x.com/spikeolaf) さんが作成された lr-parser-101 を使って、みんなでワイワイしながらパーサを生成しました！

[yui\-knk/lr\-parser\-101](https://github.com/yui-knk/lr-parser-101)

### 第 6 章

第 5 章では括弧を含む四則演算の計算式を受け取って、その計算結果を表示するシンプルなパーサを作った。

第 6 章では `racc` の記法を利用して文法ルールをより直感的に記述してみる。

#### シンプルな足し算

まず、以下のようなシンプルな文法ルールを書いてみる。

```ruby
❯ cat calc.y | grep -A 7 rule 
rule
  program: expr { p val[0] }
         ;

  expr: expr '+' NUMBER { result = val[0] + val[2] }
      | NUMBER { result = val[0] }
      ;
end
```

`racc` を利用してパーサを生成する。Rakefile にパーサを生成するためのコマンドが記載されているので、ここではそのコマンドを直接実行してみる。

```sh
❯ cat Rakefile
task default: :compile

task :compile do
  puts "Compiling parser ..."

  `racc calc.y -o calc.rb`
end

❯ ls | grep calc.rb

❯ racc calc.y -o calc.rb

❯ ls | grep calc.rb     
calc.rb
```

生成されたパーサを実行してみる。

```sh
❯ ruby calc.rb
Enter the formula:
1 
1

Enter the formula:
1 + 2
3

Enter the formula:
1 + 2 + 3
6

Enter the formula:
q
Bye!
```

確かに足し算の計算式を受け取って、その計算結果を表示できた。

#### shift/reduce conflict

先ほどの文法ルールを以下のように少しだけ変更してみる。

```ruby
❯ cat calc.y | grep -A 7 rule 
rule
  program: expr { p val[0] }
         ;

  expr: expr '+' expr { result = val[0] + val[2] } # この行を変更
      | NUMBER { result = val[0] }
      ;
end
```

`racc` を利用してパーサを生成すると、shift/reduce conflict が発生する。

```sh
❯ racc calc.y -o calc.rb
1 shift/reduce conflicts
Turn on logging with "-v" and check ".output" file for details
```

`-v` オプションを付けて `racc` コマンドを再度実行すると、`calc.output` ファイルが生成される。

```sh
❯ ls | grep calc.output

❯ racc calc.y -o calc.rb -v
1 shift/reduce conflicts
Check ".output" file for details

❯ ls | grep calc.output    
calc.output
```

`calc.output` を見てみると、`state 7` で shift/reduce conflict が発生しているように見える。

```sh
❯ cat calc.output | head
state 7 contains 1 shift/reduce conflicts


-------- Grammar --------

rule 1 program: expr
rule 2 expr: expr "+" expr
rule 3 expr: NUMBER

------- Symbols -------
```

`state 7` は以下のようになっている。

```sh
❯ cat calc.output | grep -A 7 '^state 7$'
state 7

   2) expr : expr _ "+" expr
   2) expr : expr "+" expr _

  "+"           shift, and go to state 5
  "+"           [reduce using rule 2 (expr)]
  $default      reduce using rule 2 (expr)
```

確かに `1 + 2 + 3` のようなケースで shift/reduce conflict が発生しそう。

```sh
  stack(parser) | queue(lexer)
----------------------------------------------
                | NUMBER '+' NUMBER '+' NUMBER
         NUMBER | '+' NUMBER '+' NUMBER
           expr | '+' NUMBER '+' NUMBER
       expr '+' | NUMBER '+' NUMBER
expr '+' NUMBER | '+' NUMBER                  
  expr '+' expr | '+' NUMBER                  # shift/reduce conflict!
```

#### 結合性

この conflict は**結合性**を指定することで解消できる。

```ruby
 1  +  2  +  3

# 左結合
(1  +  2) +  3
```

`+` 演算子に対して左結合を指定すると、上のように足し算が左から順に実行される。

これにより、先ほどの shift/reduce conflict 発生時には reduce が常に優先される。

```ruby
 1  +  2  +  3

# 右結合
 1  + (2  +  3)
```

`+` 演算子に対して右結合を指定すると、上のように足し算が右から順に実行される。

これにより、先ほどの shift/reduce conflict 発生時には shift が常に優先される。

#### 結合性の指定方法

結合性の指定方法は以下のリファレンスに記述されている。

[規則ファイル文法リファレンス](https://i.loveruby.net/ja/projects/racc/doc/grammar.html)
<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBek1iQkE9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--9cc3514af2483a4719423bf95237d04276f1919f/image.png" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBek1iQkE9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--9cc3514af2483a4719423bf95237d04276f1919f/image.png" width="2588" height="1026" alt="image.png"></a>

#### 結合性を指定してみる

文法ルールを以下のように変更して結合性を指定してみる。ここでは左結合を指定する。

```ruby
❯ cat calc.y | grep -A 13 class
class Calc

preclow
  left '+' # 左結合を指定
prechigh

rule
  program: expr { p val[0] }
         ;

  expr: expr '+' expr { result = val[0] + val[2] }
      | NUMBER { result = val[0] }
      ;
end
```

`racc` を利用してパーサを生成すると、shift/reduce conflict が解消していることがわかる。

```sh
❯ ls | grep calc.rb

❯ racc calc.y -o calc.rb   

❯ ls | grep calc.rb     
calc.rb
```

生成されたパーサを実行してみる。

```sh
❯ ruby calc.rb
Enter the formula:
1 + 2 + 3
6

Enter the formula:
q
Bye!
```

確かに足し算の計算式を受け取って、計算した結果を表示できた。

#### 掛け算

先ほどの文法ルールを以下のように少しだけ変更してみる。

```ruby
❯ cat calc.y | grep -A 14 class
class Calc

preclow
  left '+' '*' # この行を変更
prechigh

rule
  program: expr { p val[0] }
         ;

  expr: expr '+' expr { result = val[0] + val[2] }
      | expr '*' expr { result = val[0] * val[2] } # この行を追加
      | NUMBER { result = val[0] }
      ;
end
```

`racc` を利用してパーサを生成する。

```sh
❯ ls | grep calc.rb

~/workspace/lr-parser-101/chapter_6 main*
❯ racc calc.y -o calc.rb       

~/workspace/lr-parser-101/chapter_6 main*
❯ ls | grep calc.rb     
calc.rb
```

生成されたパーサを実行してみる。

```sh
❯ ruby calc.rb
Enter the formula:
1 * 2 + 3        
5

Enter the formula:
1 + 2 * 3
9

Enter the formula:
q
Bye!
```

`1 * 2 + 3` は正しく計算できているが、`1 + 2 * 3` は足し算が先に実行されてしまっているように見える。

#### 演算子の優先順位の指定方法

演算子の優先順位の指定方法は以下のリファレンスに記述されている。

[規則ファイル文法リファレンス](https://i.loveruby.net/ja/projects/racc/doc/grammar.html)
<a href="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBek1iQkE9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--9cc3514af2483a4719423bf95237d04276f1919f/image.png" target="_blank" rel="noopener noreferrer"><img src="https://bootcamp.fjord.jp/rails/active_storage/blobs/redirect/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBBek1iQkE9PSIsImV4cCI6bnVsbCwicHVyIjoiYmxvYl9pZCJ9fQ==--9cc3514af2483a4719423bf95237d04276f1919f/image.png" width="2588" height="1026" alt="image.png"></a>

#### 演算子の優先順位を指定してみる

文法ルールを以下のように変更して演算子の優先順位を指定してみる。

```ruby
❯ cat calc.y | grep -A 15 class
class Calc

preclow
  left '+'
  left '*' # 掛け算を優先
prechigh

rule
  program: expr { p val[0] }
         ;

  expr: expr '+' expr { result = val[0] + val[2] }
      | expr '*' expr { result = val[0] * val[2] }
      | NUMBER { result = val[0] }
      ;
end
```

`racc` を利用してパーサを生成する。

```sh
❯ ls | grep calc.rb

❯ racc calc.y -o calc.rb

❯ ls | grep calc.rb     
calc.rb
```

生成されたパーサを実行してみる。

```sh
❯ ruby calc.rb
Enter the formula:
1 * 2 + 3
5

Enter the formula:
1 + 2 * 3
7

Enter the formula:
q
Bye!
```

確かに足し算と掛け算が混ざった計算式を受け取って、その計算結果を表示できた。
