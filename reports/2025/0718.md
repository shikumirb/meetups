# [\#9](https://shikumirb.connpass.com/event/362599/)

## やったこと

[kaneko\.y（\@spikeolaf）](https://x.com/spikeolaf) さんから教えていただいた方法で、みんなでワイワイしながら Ruby をビルドしました！

さらに、ビルドしたときに生成される `parse.output` を使って LALR パーサの動きをログから読み解きました！[^1]

[^1]: `parse.output` を生成するための Ruby のビルド方法については以下を参照。[meetups/reports/2025/0704\.md at main · shikumirb/meetups](https://github.com/shikumirb/meetups/blob/main/reports/2025/0704.md#parseoutput-%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE-ruby-%E3%81%AE%E3%83%93%E3%83%AB%E3%83%89%E6%96%B9%E6%B3%95)

### LALR パーサの動きをログ出力する

空の Ruby スクリプトを実行したときのデバッグ出力を読み解いてみる。

```
~/workspace/ruby_under_a_microscope/ruby/build master ⇣
❯ ./miniruby --parser=parse.y --dump=y -e '' 
add_delayed_token:7632 (0: 0|0|0)
Starting parse
Entering state 0
Stack now 0
Reducing stack by rule 1 (line 3158):
lex_state: NONE -> BEG at line 3159
vtable_alloc:14798: 0x0000600002e02cc0
vtable_alloc:14799: 0x0000600002e02ce0
cmdarg_stack(push): 0 at line 14813
cond_stack(push): 0 at line 14814
-> $$ = nterm $@1 (1.0-1.0: )
Entering state 1
Stack now 0 1
Reading a token
parser_dispatch_scan_event:10521 (1: 0|1|0)
Now at end of input.
Reducing stack by rule 811 (line 6722):
-> $$ = nterm none (1.0-1.0: )
Entering state 142
Stack now 0 1 142
Reducing stack by rule 6 (line 3184):
   $1 = nterm none (1.0-1.0: )
-> $$ = nterm top_stmts (1.0-1.0: NODE_BEGIN)
Entering state 70
Stack now 0 1 70
Now at end of input.
Reducing stack by rule 2 (line 3164):
-> $$ = nterm option_terms (1.0-1.0: )
Entering state 332
Stack now 0 1 70 332
Reducing stack by rule 4 (line 3164):
   $1 = nterm top_stmts (1.0-1.0: NODE_BEGIN)
   $2 = nterm option_terms (1.0-1.0: )
-> $$ = nterm compstmt_top_stmts (1.0-1.0: NODE_BEGIN)
Entering state 69
Stack now 0 1 69
Reducing stack by rule 5 (line 3164):
   $1 = nterm $@1 (1.0-1.0: )
   $2 = nterm compstmt_top_stmts (1.0-1.0: NODE_BEGIN)
vtable_free:14824: cur_table(0x0000600002e02cc0)
vtable_free:14824: cur_table(0x0000600002e02ce0)
cmdarg_stack(pop): 0 at line 14854
cond_stack(pop): 0 at line 14855
-> $$ = nterm program (1.0-1.0: )
Entering state 2
Stack now 0 2
Now at end of input.
Shifting token "end-of-input" (1.1-1.1: )
Entering state 143
Stack now 0 2 143
Stack now 0 2 143
Cleanup: popping token "end-of-input" (1.1-1.1: )
Cleanup: popping nterm program (1.0-1.0: )
```

---

まずは、デバッグ出力の最初の 4 行を読んでみる。

```
add_delayed_token:7632 (0: 0|0|0)
Starting parse
Entering state 0
Stack now 0
```

上のログの 1 行目 `add_delayed_token:7632 (0: 0|0|0)` はよくわからないので、一旦スキップする。。

上のログの 3 行目 `Entering state 0` は、パーサの状態が `state 0` に変化したことを示している。

上のログの 4 行目 `Stack now 0` は、パーサの状態を管理するスタックに `state 0` が積まれたことを示している。

現時点のパーサに関する情報を図示すると以下のような感じ。

```
[state]
stack
-----
0

[token]
stack | queue
--------------------
      | end-of-input
```

---

ここで、`parse.output` の `State 0` の箇所を読んで、パーサの次のアクションを予想してみる。

```
 State 0
   
    0 $accept: • program "end-of-input"
    1 $@1: ε •
    5 program: • $@1 compstmt_top_stmts
   
    $default  reduce using rule 1 ($@1)
```

上の `$default  reduce using rule 1 ($@1)` は、「先読みなしで文法ルール 1 に従って還元しろ」という指示に見える。

これにより、パーサは無から `$@1` というトークンを生成して、トークンを管理するスタックに `$@1` を積むはず。

---

先ほどの予想があっているかを確認する。デバッグ出力の次の 7 行を読んでみる。

```
Reducing stack by rule 1 (line 3158):
lex_state: NONE -> BEG at line 3159
vtable_alloc:14798: 0x0000600002e02cc0
vtable_alloc:14799: 0x0000600002e02ce0
cmdarg_stack(push): 0 at line 14813
cond_stack(push): 0 at line 14814
-> $$ = nterm $@1 (1.0-1.0: )
```

上のログの 1 行目 `Reducing stack by rule 1 (line 3158):` は、パーサが文法ルール 1 に従って還元したことを示している。

上のログの 7 行目 `-> $$ = nterm $@1 (1.0-1.0: )` は、パーサが無から `$@1` というトークンを生成してスタックの上に積んだことを示している。

予想通り！🎉

現時点のパーサに関する情報を図示すると以下のような感じ。

```
[state]
stack
-----
0

[token]
stack | queue
--------------------
$@1   | end-of-input
```

---

ここで、`parse.output` の `State 0` の箇所を読んで、パーサの状態遷移を予想してみる。

```
State 0
   
    0 $accept: • program "end-of-input"
    1 $@1: ε •
    5 program: • $@1 compstmt_top_stmts
   
    $default  reduce using rule 1 ($@1)
   
    $@1      go to state 1
    program  go to state 2
```

上の `$@1      go to state 1` は、「スタックの一番上が `$@1` のときは `state 1` に状態遷移しろ」という指示に見える。

これにより、パーサは `state 1` に状態遷移して、状態を管理するスタックに `state 1` を積むはず。

---

先ほどの予想があっているかを確認する。デバッグ出力の次の 2 行を読んでみる。

```
Entering state 1
Stack now 0 1
```

上のログの 1 行目 `Entering state 1` は、パーサの状態が `state 1` に変化したことを示している。

上のログの 2 行目 `Stack now 0 1` は、パーサの状態を管理するスタックに `state 1` が積まれたことを示している。

予想通り！🎉

現時点のパーサに関する情報を図示すると以下のような感じ。

```
[state]
stack
-----
0 1

[token]
stack | queue
--------------------
$@1   | end-of-input
```
---

ここで、`parse.output` の `State 1` の箇所を読んで、パーサの次のアクションを予想してみる。

```
State 1

    4 compstmt_top_stmts: • top_stmts option_terms
（中略）
  811 none: ε •  ["end-of-input", '\n', ';']

    error                       shift, and go to state 3
（中略）
    "end-of-input"  reduce using rule 811 (none)
```

上の `"end-of-input"  reduce using rule 811 (none)` は、「先読みを行い、トークン列の先頭が `"end-of-input"` のときは文法ルール 811 に従って還元しろ」という指示に見える。

これにより、パーサは無から `none` というトークンを生成して、トークンを管理するスタックに `none` を積むはず。

---

先ほどの予想があっているかを確認する。デバッグ出力の次の 5 行を読んでみる。

```
Reading a token
parser_dispatch_scan_event:10521 (1: 0|1|0)
Now at end of input.
Reducing stack by rule 811 (line 6722):
-> $$ = nterm none (1.0-1.0: )
```

上のログの 1 行目 `Reading a token` は、パーサがトークン列の先頭を先読みしたことを示している。

上のログの 3 行目 `Now at end of input.` は、先読みした結果、トークン列の先頭が `"end-of-input"` だったことを示している。

上のログの 4 行目 `Reducing stack by rule 811 (line 6722):` は、パーサが文法ルール 811 に従って還元したことを示している。

上のログの 5 行目 `-> $$ = nterm none (1.0-1.0: )` は、パーサが無から `none` というトークンを生成してスタックの上に積んだことを示している。

予想通り！🎉

現時点のパーサに関する情報を図示すると以下のような感じ。

```
[state]
stack
-----
0 1

[token]
stack    | queue
-----------------------
$@1 none | end-of-input
```
---

ここで、parse.output の `State 1` の箇所を読んで、パーサの状態遷移を予想してみる。

```
State 1

    4 compstmt_top_stmts: • top_stmts option_terms
（中略）
  811 none: ε •  ["end-of-input", '\n', ';']

    error                       shift, and go to state 3
（中略）
    "end-of-input"  reduce using rule 811 (none)

    compstmt_top_stmts                  go to state 69
（中略）
    none                                go to state 142
```

上の `none                                go to state 142` は、「スタックの一番上が `none` のときは `state 142` に状態遷移しろ」という指示に見える。

これにより、パーサは `state 142` に状態遷移して、状態を管理するスタックに `state 142` を積むはず。

---

先ほどの予想があっているかを確認する。デバッグ出力の次の 2 行を読んでみる。

```
Entering state 142
Stack now 0 1 142
```

上のログの 1 行目 `Entering state 142` は、パーサの状態が `state 142` に変化したことを示している。

上のログの 2 行目 `Stack now 0 1 142` は、パーサの状態を管理するスタックに `state 142` が積まれたことを示している。

予想通り！🎉

現時点のパーサに関する情報を図示すると以下のような感じ。

```
[state]
stack
-------
0 1 142

[token]
stack    | queue
-----------------------
$@1 none | end-of-input
```
---

ここで、`parse.output` の `State 142` の箇所を読んで、パーサの次のアクションを予想してみる。

```
State 142
    
    6 top_stmts: none •
    
    $default  reduce using rule 6 (top_stmts)
```

上の `$default  reduce using rule 6 (top_stmts)` は、「先読みなしで文法ルール 6 に従って還元しろ」という指示に見える。

これにより、パーサは `none` から `top_stmts` というトークンを生成して、トークンを管理するスタックに `top_stmts` を積むはず。

---

先ほどの予想があっているかを確認する。デバッグ出力の次の 3 行を読んでみる。

```
Reducing stack by rule 6 (line 3184):
   $1 = nterm none (1.0-1.0: )
-> $$ = nterm top_stmts (1.0-1.0: NODE_BEGIN)
```

上のログの 1 行目 `Reducing stack by rule 6 (line 3184):` は、パーサが文法ルール 6 に従って還元したことを示している。

上のログの 2 行目 `$1 = nterm none (1.0-1.0: )` と 3 行目 `-> $$ = nterm top_stmts (1.0-1.0: NODE_BEGIN)` は、パーサが `none` から `top_stmts` というトークンを生成してスタックの上に積んだことを示している。

予想通り！🎉

現時点のパーサに関する情報を図示すると以下のような感じ。

```
[state]
stack
-------
0 1 142

[token]
stack         | queue
----------------------------
$@1 top_stmts | end-of-input
```
---

ここで、parse.output の `State 142` の箇所を読んで、パーサの状態遷移を予想してみる。

```
State 142
    
    6 top_stmts: none •
    
    $default  reduce using rule 6 (top_stmts)
    
    
State 143
```

上を見ると、次の状態遷移先が明示的に書かれていない。

これは「アクションが終わったら元の状態に戻れ」という指示に見える。

これにより、パーサは状態を管理するスタックから `state 142` をポップして、一つ前の状態である `state 1` に状態遷移するはず。

さらに、parse.output の `State 1` の箇所を読んで、パーサの状態遷移を予想してみる。

```
State 1

    4 compstmt_top_stmts: • top_stmts option_terms
（中略）
  811 none: ε •  ["end-of-input", '\n', ';']

    error                       shift, and go to state 3
（中略）
    none                                go to state 142

    compstmt_top_stmts                  go to state 69
    top_stmts                           go to state 70
（中略）
    none                                go to state 142
```

上の `top_stmts                           go to state 70` は、「スタックの一番上が `top_stmts` のときは `state 70` に状態遷移しろ」という指示に見える。

これにより、パーサは `state 70` に状態遷移して、状態を管理するスタックに `state 70` を積むはず。

---

先ほどの予想があっているかを確認する。デバッグ出力の次の 2 行を読んでみる。

```
Entering state 70
Stack now 0 1 70
```

上のログの 1 行目 `Entering state 70` は、パーサの状態が `state 70` に変化したことを示している。

上のログの 2 行目 `Stack now 0 1 70` は、パーサの状態を管理するスタックから `state 142` がポップされた後に `state 70` が積まれたことを示している。

予想通り！🎉

現時点のパーサに関する情報を図示すると以下のような感じ。

```
[state]
stack
------
0 1 70

[token]
stack         | queue
----------------------------
$@1 top_stmts | end-of-input
```

ここまで読めれば、後は上のようにして最後まで読み解くことができる。
