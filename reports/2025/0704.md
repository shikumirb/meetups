# [\#7](https://shikumirb.connpass.com/event/360924/)

## やったこと

今回は特別ゲストとして [kaneko\.y（\@spikeolaf）](https://x.com/spikeolaf) さんに来ていただいて、Parser generator についてみんなでワイワイ質問させていただきました！

[D\-Swordman（\@junk0612）](https://x.com/junk0612) さんにもチャットで色々と解説していただき、とても勉強になりました！

### Q & A

#### 
- 疑問 1 : 
Parser は先読みするかどうかをどうやって判断しているのか？
- 回答 1 : 
現在のステートをもとに先読みするかどうかを機械的に決めている。

これを理解するには、`parse.output` というファイルを見ると便利。

このファイルはステートとアクションの対応表のようなものが記述されていて、Parser はこのような対応表にもとづいて機械的に先読みするかどうかを判断する。

例えば、`parse.output` の State 99 の箇所を読んでみる。

```ruby
State 99

  283 arg: primary •  ["end-of-input", "'rescue'", "'ensure'", "'end'", "'then'", "'elsif'", "'else'", "'when'", "'in'", "'do' for condition", "'do' for block", "'do' for lambda", "'and'", "'or'", "'if' modifier", "'unless' modifier", "'while' modifier", "'until' modifier", "'rescue' modifier", "dummy end", "**", "<=>", "==", "===", "!=", ">=", "<=", "&&", "||", "=~", "!~", "..", "...", "<<", ">>", "=>", "{ arg", "'}'", tLAMBEG, '?', ':', '>', '<', '|', '^', '&', '+', '-', '*', '/', '%', '}', '\n', ',', ')', ']', ';']
  395 value_expr_primary: primary •  ['.', "&.", "::", '[']

    '.'       reduce using rule 395 (value_expr_primary)
    "&."      reduce using rule 395 (value_expr_primary)
    "::"      reduce using rule 395 (value_expr_primary)
    '['       reduce using rule 395 (value_expr_primary)
    $default  reduce using rule 283 (arg)
```

これを読むと、Parser は先読みを行い、その結果を利用して以下のようにアクションを決めていることがわかる。

- 先読みしたトークンが `.`, `&.`, `::`, `[` のいずれかのときは、文法ルール 395 を利用して還元（Reduce）する
- それ以外のときは、文法ルールの 283 を利用して還元（Reduce）する

ちなみに、Ruby のビルド時にオプションを指定すると `parse.output` を生成することができる。

```sh
# parse.output を生成するための Ruby のビルド手順（以下を一部改変）
# https://github.com/ruby/ruby/blob/cf7b871a94f2d44eb35676a3dbf9278a73a612c1/doc/contributing/building_ruby.md

# Step1. Ruby のソースコードの取得
$ git clone https://github.com/ruby/ruby.git
$ cd ruby 
$ ./autogen.sh # Step4 で利用する configure スクリプトが生成される

# Step2. build ディレクトリの作成
$ mkdir build && cd build

# Step3. ~/.rubies ディレクトリの作成
$ mkdir ~/.rubies

# Step4. configure スクリプトの実行（これにより、Makefile が生成される）
$ ../configure --prefix="${HOME}/.rubies/ruby-master"

# Step5. Ruby のビルド
# GitHub に記載されている手順と異なるので注意！
$ make YFLAGS="--report=states,itemsets,lookaheads,solved" miniruby
```

`parse.output` を生成するために、Step 5 だけ GitHub に記載されている手順と異なることに注意！

---

- 疑問 2 : 
現在のステートはどうやって決まっているのか？
- 回答 2 : 
`parse.y` の文法ルールからオートマトンが生成され、オートマトンと入力に従って現在のステートが決まる。

例えば、以下のようなスクリプトのみを受け付ける Parser に対応するオートマトンを考える。

```ruby
class A
  def m
  end
end
```

これは以下のように図示できる。2 つのオートマトンがスタックに積まれているイメージ。

![入れ子になったオートマトンの図](https://cdn-ak.f.st-hatena.com/images/fotolife/y/yui-knk/20231125/20231125183717.png)
出典：[Ruby Parser開発日誌 (14) - LR parser完全に理解した](https://yui-knk.hatenablog.com/entry/2023/12/06/082203)

ちなみに、以下のようにオプションを指定して Ruby スクリプトを実行すると、`Stack now 0 1 40` のようなログが出力されるが、これを理解するには上のようなイメージがあると便利。

```sh
❯ ./miniruby --parser=parse.y --dump=y -e '1'
add_delayed_token:7632 (0: 0|0|0)
Starting parse
Entering state 0
Stack now 0
（中略）
Entering state 1
Stack now 0 1
（中略）
Entering state 40
Stack now 0 1 40
```

`Stack now 0 1 40` というログは、ステートを管理するスタックに 0, 1, 40 という 3 つのステートが積まれていると解釈できる。

---

- 疑問 3 : 
LALR(1) ではなく、LALR(2) のように先読みするトークンの数が 2 以上の Parser は存在するのか？
- 回答 3 : 
そのような Parser を作ることはできるが、先読みするトークン数は 1 で十分なので実際には存在しないと思われる。

---

- 疑問 4 : 
先読みするトークン数が 1 で十分なのは以下のどちらの理由によるのか？
  - 先読みするトークン数が 1 で済むように言語仕様を決めている
  -  どんな言語仕様であっても先読みするトークン数は 1 で十分であることが理論的に保証されている
- 回答 4 : 
前者。ちなみに、先読みするトークン数が 1 で済まないような言語仕様が記述された `parse.y` を Lrama のようなパーサジェネレータに食べさせると、コンフリクトを検知してくれる。

---

- 疑問 5 : 
Ruby の場合、`1 + \n 2` のようなスクリプトを Lexer に食べさせると `+` の後ろの改行を無視するが、`parse.y` 側にこの言語仕様を記述していないのはなぜか？
- 回答 5 : 
歴史的な経緯で Lexer と Parser の責任の境界が曖昧になってしまった結果、現状のような役割分担になっている可能性がある。マイクロサービスでよく見られる状況をイメージすると理解しやすいかも。
