# [\#22](https://shikumirb.connpass.com/event/381925/)

## やったこと

今日は CRuby のコード（ISeq を生成している `compile.c`）を読みました！

https://github.com/ruby/ruby/blob/491e38902c2f5deef5dbb249cdf609ae2bb52f1e/compile.c#L10806-L10826

### コードリーディング

CRuby のコンパイラは AST を深さ優先探索で辿りながら、（基本的には）帰りがけ順で ISeq を生成する。

ソースコードを読んで、この処理の流れを概観する。

---

`compile.c` の関数 `iseq_compile_each` がコンパイル処理の入り口。

関数 `iseq_compile_each` を最初に呼び出す際は、第 3 引数にルートノードが渡される？

https://github.com/ruby/ruby/blob/5eb17ea4aae32d657c1816de64acd3ef7abb454f/compile.c#L10806-L10826
```
/**
  compile each node

  self:  InstructionSequence
  node:  Ruby compiled node
  popped: This node will be popped
 */
static int
iseq_compile_each(rb_iseq_t *iseq, LINK_ANCHOR *ret, const NODE *node, int popped)
{
    if (node == 0) {
        if (!popped) {
            int lineno = ISEQ_COMPILE_DATA(iseq)->last_line;
            if (lineno == 0) lineno = FIX2INT(rb_iseq_first_lineno(iseq));
            debugs("node: NODE_NIL(implicit)\n");
            ADD_SYNTHETIC_INSN(ret, lineno, -1, putnil);
        }
        return COMPILE_OK;
    }
    return iseq_compile_each0(iseq, ret, node, popped);
}
```

関数 `iseq_compile_each0` の中で、ノードの種類に応じて ISeq を生成する処理を分岐させている。

https://github.com/ruby/ruby/blob/5eb17ea4aae32d657c1816de64acd3ef7abb454f/compile.c#L10828-L11598

```
static int
iseq_compile_each0(rb_iseq_t *iseq, LINK_ANCHOR *const ret, const NODE *const node, int popped)
{
    const enum node_type type = nd_type(node);
    （中略）
    switch (type) {
      （中略）
      case NODE_CALL:   /* obj.foo */
      case NODE_OPCALL: /* foo[] */
        if (compile_call_precheck_freeze(iseq, ret, node, node, popped) == TRUE) {
            break;
        }
      case NODE_QCALL: /* obj&.foo */
      case NODE_FCALL: /* foo() */
      case NODE_VCALL: /* foo (variable or call) */
        if (compile_call(iseq, ret, node, type, node, popped, false) == COMPILE_NG) {
            goto ng;
        }
        break;
      （中略）
      default:
        UNKNOWN_NODE("iseq_compile_each", node, COMPILE_NG);
      ng:
        debug_node_end();
        return COMPILE_NG;
    }
    （中略）
    return COMPILE_OK;
}
```

`NODE_CALL`, `NODE_FCALL`, `NODE_VCALL` が ISeq に変換される流れを追うために、関数 `compile_call` の中を見てみる。

https://github.com/ruby/ruby/blob/5eb17ea4aae32d657c1816de64acd3ef7abb454f/compile.c#L9432-L9613

---

`compile_call`の中で、まずレシーバのコンパイルをしている。

```
static int
compile_call(rb_iseq_t *iseq, LINK_ANCHOR *const ret, const NODE *const node, const enum node_type type, const NODE *const line_node, int popped, bool assume_receiver)
{
    （中略）
    /* receiver */
    if (!assume_receiver) {
        if (type == NODE_CALL || type == NODE_OPCALL || type == NODE_QCALL) {
            （中略）
            if (mid == idCall &&
                nd_type_p(get_nd_recv(node), NODE_LVAR) &&
                iseq_block_param_id_p(iseq, RNODE_LVAR(get_nd_recv(node))->nd_vid, &idx, &level)) {
                ADD_INSN2(recv, get_nd_recv(node), getblockparamproxy, INT2FIX(idx + VM_ENV_DATA_SIZE - 1), INT2FIX(level));
            }
            else if (private_recv_p(node)) {
                ADD_INSN(recv, node, putself);
                flag |= VM_CALL_FCALL;
            }
            else {
                CHECK(COMPILE(recv, "recv", get_nd_recv(node)));
            }
            （中略）
        }
        else if (type == NODE_FCALL || type == NODE_VCALL) {
            ADD_CALL_RECEIVER(recv, line_node);
        }
    }
```

- `NODE_CALL` の場合...
  - `COMPILE(recv, "recv", get_nd_recv(node))` を呼び、レシーバに対して再帰的に `iseq_compile_each` を実行している？
  - https://github.com/ruby/ruby/blob/5eb17ea4aae32d657c1816de64acd3ef7abb454f/compile.c#L327-L330
- `NODE_FCALL`, `NODE_VCALL` の場合...
  - `ADD_CALL_RECEIVER(recv, line_node)` を呼び、`putself` という ISeq を生成する 
  - https://github.com/ruby/ruby/blob/5eb17ea4aae32d657c1816de64acd3ef7abb454f/compile.c#L277-L278

---

レシーバのコンパイルが終わったら、次に引数のコンパイルをしている。

```
    /* args */
    if (type != NODE_VCALL) {
        argc = setup_args(iseq, args, get_nd_args(node), &flag, &keywords);
        CHECK(!NIL_P(argc));
    }
    else {
        argc = INT2FIX(0);
    }
```

- `NODE_VCALL` 以外の場合...
  - `setup_args` を呼び、必要に応じて再帰的に `iseq_compile_each` を実行している？
- `NODE_VCALL` の場合...
  - 引数の数を表す `argc` に 0 を代入する（`iseq_compile_each` を再帰的に実行しない）

---

最後に `ADD_SEND_R` を呼んでメソッド呼び出しのコンパイルをしている。

確かに、AST をルートノードから深さ優先で辿りながら、（基本的には）帰りがけ順で ISeq を生成していそう。
