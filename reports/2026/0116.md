# [\#21](https://shikumirb.connpass.com/event/381346/)

## やったこと

今日も `ruby` コマンドの `--dump` オプションを利用して LR パーサのデバッグ情報を出力してワイワイしました！

### `--dump` オプション

以下では Ruby のバージョン 3.4.5 を利用している。

```sh
❯ ruby -v
ruby 3.4.5 (2025-07-16 revision 20cda200d3) +PRISM [x86_64-darwin22]
```

`--dump` オプションを使うと、パーサジェネレータが生成するデバッグ情報やパーサが生成する AST を出力することができる。

```sh
❯ ruby --help | grep -A 6 "Dump List"
Dump List:
（略）
  yydebug         yydebug of yacc parser generator.
  parsetree       Abstract syntax tree (AST).
（略）
```

### AST の出力

`1 + 2` の AST は以下のようにして出力できる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "1 + 2"
（中略）
# @ NODE_SCOPE (id: 4, line: 1, location: (1,0)-(1,5))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_OPCALL (id: 3, line: 1, location: (1,0)-(1,5))*
#     +- nd_mid: :+
#     +- nd_recv:
#     |   @ NODE_INTEGER (id: 0, line: 1, location: (1,0)-(1,1))
#     |   +- val: 1
#     +- nd_args:
#         @ NODE_LIST (id: 2, line: 1, location: (1,4)-(1,5))
#         +- as.nd_alen: 1
#         +- nd_head:
#         |   @ NODE_INTEGER (id: 1, line: 1, location: (1,4)-(1,5))
#         |   +- val: 2
#         +- nd_next:
#             (null node)
```

木構造を図示するとこんな感じ？

```
         @ NODE_SCOPE
               |
         @ NODE_OPCALL
              / \
@ NODE_INTEGER   @ NODE_LIST 
                       |
                 @ NODE_INTEGER
```

**2 項演算子**は `NODE_OPCALL` というノードで表現されていることに注意する。

---

`1.+(2)` の AST は以下のようにして出力できる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "1.+(2)"
（中略）
# @ NODE_SCOPE (id: 4, line: 1, location: (1,0)-(1,6))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_CALL (id: 3, line: 1, location: (1,0)-(1,6))*
#     +- nd_mid: :+
#     +- nd_recv:
#     |   @ NODE_INTEGER (id: 0, line: 1, location: (1,0)-(1,1))
#     |   +- val: 1
#     +- nd_args:
#         @ NODE_LIST (id: 2, line: 1, location: (1,4)-(1,5))
#         +- as.nd_alen: 1
#         +- nd_head:
#         |   @ NODE_INTEGER (id: 1, line: 1, location: (1,4)-(1,5))
#         |   +- val: 2
#         +- nd_next:
#             (null node)
````

木構造を図示するとこんな感じ？

```
         @ NODE_SCOPE
               |
         @ NODE_CALL
              / \
@ NODE_INTEGER   @ NODE_LIST 
                       |
                 @ NODE_INTEGER
```

**レシーバに対するメソッド呼び出し**は `NODE_CALL` というノードで表現されていることに注意する。

---

`sleep 1` の AST は以下のようにして出力できる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "sleep 1"
（中略）
# @ NODE_SCOPE (id: 3, line: 1, location: (1,0)-(1,7))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_FCALL (id: 1, line: 1, location: (1,0)-(1,7))*
#     +- nd_mid: :sleep
#     +- nd_args:
#         @ NODE_LIST (id: 2, line: 1, location: (1,6)-(1,7))
#         +- as.nd_alen: 1
#         +- nd_head:
#         |   @ NODE_INTEGER (id: 0, line: 1, location: (1,6)-(1,7))
#         |   +- val: 1
#         +- nd_next:
#             (null node)
```

木構造を図示するとこんな感じ？

```
@ NODE_SCOPE
      |
@ NODE_FCALL
      |
@ NODE_LIST 
      |
@ NODE_INTEGER
```

**レシーバなし、引数ありのメソッド呼び出し**は `NODE_FCALL` というノードで表現されていることに注意する。

---

`sleep` の AST は以下のようにして出力できる。

```sh
❯ ruby --parser=parse.y --dump=parsetree -e "sleep"  
（中略）
# @ NODE_SCOPE (id: 1, line: 1, location: (1,0)-(1,5))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_VCALL (id: 0, line: 1, location: (1,0)-(1,5))*
#     +- nd_mid: :sleep
```

木構造を図示するとこんな感じ？

```
@ NODE_SCOPE
      |
@ NODE_VCALL
```

**レシーバなし、引数なしのメソッド呼び出し**は `NODE_VCALL` というノードで表現されていることに注意する。

---

### スペースの有無と優先順位

以下のようにスペースの有無で計算結果が異なる場合がある。

```ruby
irb(main):001* def foo(n)
irb(main):002*   n ** 2
irb(main):003> end
=> :foo
irb(main):004> foo(3) * 3
=> 27
irb(main):005> foo (3) * 3
=> 81
```

上の結果を見た感じ、以下のようになっているように見える。

- `foo(3) * 3`
  - `foo(3)` が最初に呼ばれて、その結果の `9` を 3 倍している
- `foo (3) * 3`
  - `(3) * 3` が最初に呼ばれて、その結果の `9` を `foo` に渡して 2 乗している

AST を出力してこの予想を確かめる。

```ruby
❯ cat shikumi.rb 
def foo(n)
  n ** 2
end

foo(3) * 3
foo (3) * 3
```

```sh
❯ ruby --parser=parse.y --dump=parsetree shikumi.rb 
（中略）
# @ NODE_SCOPE (id: 24, line: 1, location: (1,0)-(6,11))
# +- nd_tbl: (empty)
# +- nd_args:
# |   (null node)
# +- nd_body:
#     @ NODE_BLOCK (id: 15, line: 1, location: (1,0)-(6,11))
#     +- nd_head (1):
（中略）
#     +- nd_head (2):
#     |   @ NODE_OPCALL (id: 14, line: 5, location: (5,0)-(5,10))*
#     |   +- nd_mid: :*
#     |   +- nd_recv:
#     |   |   @ NODE_FCALL (id: 9, line: 5, location: (5,0)-(5,6))
#     |   |   +- nd_mid: :foo
#     |   |   +- nd_args:
#     |   |       @ NODE_LIST (id: 11, line: 5, location: (5,4)-(5,5))
#     |   |       +- as.nd_alen: 1
#     |   |       +- nd_head:
#     |   |       |   @ NODE_INTEGER (id: 10, line: 5, location: (5,4)-(5,5))
#     |   |       |   +- val: 3
#     |   |       +- nd_next:
#     |   |           (null node)
#     |   +- nd_args:
#     |       @ NODE_LIST (id: 13, line: 5, location: (5,9)-(5,10))
#     |       +- as.nd_alen: 1
#     |       +- nd_head:
#     |       |   @ NODE_INTEGER (id: 12, line: 5, location: (5,9)-(5,10))
#     |       |   +- val: 3
#     |       +- nd_next:
#     |           (null node)
#     +- nd_head (3):
#         @ NODE_FCALL (id: 17, line: 6, location: (6,0)-(6,11))*
#         +- nd_mid: :foo
#         +- nd_args:
#             @ NODE_LIST (id: 22, line: 6, location: (6,4)-(6,11))
#             +- as.nd_alen: 1
#             +- nd_head:
#             |   @ NODE_OPCALL (id: 21, line: 6, location: (6,4)-(6,11))
#             |   +- nd_mid: :*
#             |   +- nd_recv:
#             |   |   @ NODE_INTEGER (id: 18, line: 6, location: (6,5)-(6,6))*
#             |   |   +- val: 3
#             |   +- nd_args:
#             |       @ NODE_LIST (id: 20, line: 6, location: (6,10)-(6,11))
#             |       +- as.nd_alen: 1
#             |       +- nd_head:
#             |       |   @ NODE_INTEGER (id: 19, line: 6, location: (6,10)-(6,11))
#             |       |   +- val: 3
#             |       +- nd_next:
#             |           (null node)
#             +- nd_next:
#                 (null node)
```

`nd_head(2)` と `nd_head(3)` はそれぞれ `foo(3) * 3` と `foo (3) * 3` の AST を表しているように見える。

木構造を図示するとこんな感じ？

```sh
# foo(3) * 3
       @ NODE_OPCALL
            / \
@ NODE_FCALL   @ NODE_LIST 
      |              |
@ NODE_LIST    @ NODE_INTEGER
      |
@ NODE_INTEGER

# NODE_FCALL の方が NODE_OPCALL より深いので、foo が先に計算される
```

```sh
# foo (3) * 3
         @ NODE_FCALL
               |
         @ NODE_LIST 
               |
         @ NODE_OPCALL
              / \
@ NODE_INTEGER   @ NODE_LIST
                       |
                 @ NODE_INTEGER

# NODE_OPCALL の方が NODE_FCALL より深いので、* が先に計算される
```

確かに AST を見た感じ、以下の仮説は正しそう。

> - `foo(3) * 3`
>   - `foo(3)` が最初に呼ばれて、その結果の `9` を 3 倍している
> - `foo (3) * 3`
>   - `(3) * 3` が最初に呼ばれて、その結果の `9` を `foo` に渡して 2 乗している
